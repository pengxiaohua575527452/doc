Promise.resolve().then(() => {
    console.log(0);
    return Promise.resolve("res");
}).then((res) => {
    console.log(res)
})

Promise.resolve().then(() => {
    console.log(1);
}).then(() => {
    console.log(2);
}).then(() => {
    console.log(3);
}).then(() => {
    console.log(5);
}).then(() =>{
    console.log(6);
})


then 执行完成后一定会返回一个 Promise 对象
https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/then
如果
then 内部的方法如果返回了一个指，那么返回resolve 状态

then 内部的方法没有返回一个值，那么方法resolve状态，回调函数的参数值是undefined

then 抛出一个错误，那么返回reject 状态， 错误作为拒绝状态的函数参数值

then 一定会返回一个 Promise对象

then 参数如果返回一个 promise.resolve || 有返回值 || 没有显示返回的值都 === Promise.resolve() 状态

then 参数内部如果 抛出错误 || promise.reject  === promise.reject() 状态

then 返回一个promise === 返回一个没有定义过的 Promise 对象


cath 执行完成后也一定会返回一个 Promise 对象
cath 内部调用的 then(undefined, onRejected) 方法



Promise 约定 

再本轮 事件循环 运行完成之前，回调函数是不会被调用的 （一个消息被处理完成之前,下一个消息处理开始之前）

即使异步操作已经完成，then 添加的回调函数也会被调用 then添加的回调函数始终都会被调用
使用then添加回调可以再执行完成之后

Promise.resolve() 和 Promise.reject()是手动创建一个已经resolve或者reject的promise快捷方法。

then中的函数被置入了一个微任务队列



then 可以添加多个回调函数，他们会按照插入的顺序依次调用；

then 里面的函数始终是异步调用


并发模型与事件循环

基于事件循环的并发模型，

事件循环

运行时

队列： 包含了一个带处理消息的消息队列， 每一个消息都关联着一个用以处理这个消息的回调函数

1： 从队列中拿出最先进入对象的消息，调用相对应的回调函数
2： 回调函数执行的时候，会把相应的帧插入到栈内，执行相应的操作，知道栈清空
3： 事件循环处理队列中的下一条消息

每一条消息执行完成后，才会执行下一条消息；
消息的执行是吧相应的栈清空；
一个函数执行的时候，不会被抢占，只有这个函数运行完毕了才会运行其他的代码，然后才能修改这个函数操作的数据
- 函数运行时相关的数据，其他方式时不能够操作的；
-缺点，如果消息队列非常的长，那么程序无法及时的处理同用户的交互，用户的交互需要等到之前的消息处理完毕才可以；


向消息队列添加消息
浏览器，每一个事件发生，并且有相应的事件监听器的时候，消息就会被添加到消息队列，如果没有事件监听是，
这个事件就会被丢失；

setTimout 接受两个参数，事件值，表示了消息被事件添加到队列的最小延迟事件，这个时间时非精确的；
如果消息队列中没有其他消息，且栈中为空，那么这个消息会被马上处理，否则，会等到其他消息处理完成之后才处理；

零延迟，也不代表回调会执行，只是表示，会把这个消息添加到消息队列里面，具体的执行时间，还是需要看消息队列的长度；
原则上 事件循环永不阻塞




微任务会在宏任务之间执行 也就是 下一次事件循环之前执行完成

微任务添加
promise 
queueMicrotask()
能够创建统一的微任务队列













