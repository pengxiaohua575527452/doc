<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /**
         * call apply bind 
         * 都能够改变 通过 function 声明函数内部的this值的指向
         * 
         * 区别
         * call apply 使用的方法是一样的，传递参数的类型不同
         * bind 返回一个内部this执行指定对象的函数的副本
         * 
         * 
        */


        // // 实例
        // // 修改 函数内部this的指向
        // function sayName(){
        //     console.log('this.name: ', this.name)
        // }


        // var name = "window.name"
        // sayName()
        // // => window.name

        // sayName.call({name: 'call-name'})
        // // => call-name

        // sayName.apply({name: 'apply-name'})
        // // => apply-name

        // const sayName_v2 = sayName.bind({name: "bind-name"})
        // sayName_v2()
        // // => bind-name

        // const bill = {
        //     name: 'bill',
        //     sayName: function(){ console.log(this.name)}
        // }
        // bill.sayName()
        // // => bill

        // const billSayName = bill.sayName
        // billSayName()
        // // => window.name


        // bill.sayName.call({name: "call-name"})
        // // => call-name

        // bill.sayName.apply({name: "apply-name"})
        // // => apply-name

        // const billSayName_v2 = bill.sayName.bind({name: 'bind-name'})
        // billSayName_v2()
        // // => bind-name



        // const sayName_v3 = () => console.log('this.name: ', this.name)

        // sayName_v3()
        // // => window.name

        // sayName_v3.call({name: 'call-name'})
        // // => window.name

        // sayName_v3.apply({name: 'apply-name'})
        // // => window.name

        // const sayName_v3_v2 = sayName.bind({name: "bind-name"})
        // sayName_v3_v2()
        // // => bind-name




        // /**
        //  * 传递参数的方式
        //  * call 通过参数列表传递
        //  * apply 通过数组传递
        // */ 

        // function sum(a, b){
        //     console.log(this.total + a + b)
        // }

        // sum.call({total: 10}, 100,1000)
        // // => 1110

        // sum.apply({total: 20}, [200,2000])
        // // => 2220

        // let sum_v2 = sum.bind({total: 30}, 300, 3000)
        // sum_v2()
        // // => 3330
                
                
        // // bind 传递参数说明
        // // 第一个参数 === 函数内部的this指向
        // // 第二个参数 === 原函数的第一个参数
        // // 第三个参数 === 原函数的第二个参数 
        // // 依次类推
        // // 如果在bind的时候没有给函数传递参数or传递参数没有完全
        // // 可以在调用bind后返回的副本函数的时候再次传递
        // // 副本函数传递参数的时候 
        // // 第一个参数位置 === bind时已经传递的参数个数+1个
        // // 例如
        // // sum(a,b) 接受两个参数 
        // // sum_v3 = sum.bind({total: 50}, 形参a的实参) 已经传递了a参数
        // // 那么调用sum_v3的时候在再次传递的参数时从第二个位置开始
        // // sum_v3(形参b的实参)
        // // 参数 5000 会被忽略
        // let sum_v3 = sum.bind({total: 50}, 1)
        // sum_v3(500, 5000)
        // // => 551

 


        // // 一旦函数时bind返回的副本函数
        // // 即便这个函数作为某一个对象的方法调用
        // // 这个方法内部的this依然指向bind的对象
        // let tom = { 
        //     tom: 'tom',
        //     sayName: sayName_v2
        // }
        // // sayName 作为tom的方法调用原本内部的this应该时指向tom对象的
        // // 但是sayName是一个通过 【bind返回的函数】，
        // // 所以 sayName 方法一直指向 bind的对象
        // tom.sayName()



        // sayName_v2.call({name: "call-name"})
        // // call 无法修改 【bind返回的函数】 内部的this指向
        // // => bind-name

        // sayName_v2.apply({name: 'apply-name'})
        // // apply 无法修改 【bind返回的函数】 内部的this指向
        // // => bind-name

        // sayName_v2_bind_again = sayName_v2.bind({name: "bind-again-name"})
        // sayName_v2_bind_again()
        // // 一个bind返回的函数无法二次修改内部this指向
        // // => bind-name


        // // 偏函数
        // // 利用bind可以预先传递部分参数的功能实现偏函数
        // // 偏函数的概念： 固定一个函数的一个or多个实参，返回新函数用来接受剩余的参数
        // // bind 会固定函数内部的this所以最好不要用 bind 来实现偏函数 
        // function hello(pre, obj){
        //     console.log(`${pre}: ${obj.name}`)
        // }

        // const hello_cn = hello.bind(null, "你好：")
        // const hello_en = hello.bind(null, "hello")

        // hello_cn({name: '中文'})
        // hello_en({name: 'EN'})


        // 如果 bind 函数的参数列表为空，或者thisArg是null或undefined，执行作用域的 this 将被视为新函数的 thisArg。
        // bind的实参第一个参数如果传递unll or undefined 
        // 【bind返回函数】 this 一定指向 bind()执行时候作用域的this
        // 这个执行作用域到底表示的是什么意思？？
        // 执行作用域 === 立即执行一个 function 声明的函数的内部的this
        // 也就是 === 立即执行 function 声明的函数作用域
        // 可以这么理解 bind() 执行完成之后 会返回一个函数副本
        // 这个函数副本的执行作用域就新函数的 thisArg
        // 也就是相当于 === bind() 完成之后立即执行这个函数副本时 内部的this指向
        // 只不过 把执行放在了后面
        // 但是this === 在 bind() 执行代码处， 执行一个任意function 声明函数内部的this
        // 执行作用域可以理解为 在当前代码处立即执行一个任意 function 声明函数所处的作用域；
        
       

        // class Person {
        //     constructor(name){
        //         this.name = name
        //     }
        //     getThis(){
        //         function inside(){
        //             console.log(this)
        //         }

        //         // bind() 执行完成后所返回的 副本函数所在的作用域
        //         return inside.bind()
        //     }
        // } 

        // const bill = new Person('bill')
        // const getThis = bill.getThis();
       
        // getThis()

        function fn(){
            console.log(this)
        }

        // 应该改指向全局对象
        // 严格模式时undefined
        // 非严格模式是 window 对象
        // fn1内部的this === 在当前执行functin声明函数状态下的this
        // 也就是 fn1 内部的this === 立即执行 fn() 函数内部的this
        let fn1 = fn.bind()

        let bill = {
            name: 'bill',
            fn: fn1
        }

        bill.fn()
        // 预期是
        // => window
        // 实际
        // => window

        class Person {
            constructor(name){
                this.name = name
            }
            getThis(){
                function inside(){
                    console.log(this)
                }
                
                // 没有传递参数
                // 所以返回的副本函数内部的this
                // 指向了执行作用域的this
                // 等同于上面的 inside() 调用状态下的执行作用域
                // 只是把执行放在后面
                
                inside()
                return inside.bind()
            }
        } 

        const jack = new Person('bill')
        const getThis = jack.getThis();
        // 预期输出
        // => undefined
        // 实际输出
        // => undefined

        getThis()
        // 预期输出
        // => undefined
        // 实际输出
        // => undefined

       
    </script>
</body>
</html>