<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /**
         * call apply bind 
         * 都能够改变 通过 function 声明函数内部的this值的指向
         * 
         * 区别
         * call apply 使用的方法是一样的，传递参数的类型不同
         * bind 返回一个内部this执行指定对象的函数的副本
         * 
         * 
        */


        // // 实例
        // // 修改 函数内部this的指向
        // function sayName(){
        //     console.log('this.name: ', this.name)
        // }


        // var name = "window.name"
        // sayName()
        // // => window.name

        // sayName.call({name: 'call-name'})
        // // => call-name

        // sayName.apply({name: 'apply-name'})
        // // => apply-name

        // const sayName_v2 = sayName.bind({name: "bind-name"})
        // sayName_v2()
        // // => bind-name

        // const bill = {
        //     name: 'bill',
        //     sayName: function(){ console.log(this.name)}
        // }
        // bill.sayName()
        // // => bill

        // const billSayName = bill.sayName
        // billSayName()
        // // => window.name


        // bill.sayName.call({name: "call-name"})
        // // => call-name

        // bill.sayName.apply({name: "apply-name"})
        // // => apply-name

        // const billSayName_v2 = bill.sayName.bind({name: 'bind-name'})
        // billSayName_v2()
        // // => bind-name



        // const sayName_v3 = () => console.log('this.name: ', this.name)

        // sayName_v3()
        // // => window.name

        // sayName_v3.call({name: 'call-name'})
        // // => window.name

        // sayName_v3.apply({name: 'apply-name'})
        // // => window.name

        // const sayName_v3_v2 = sayName.bind({name: "bind-name"})
        // sayName_v3_v2()
        // // => bind-name




        // /**
        //  * 传递参数的方式
        //  * call 通过参数列表传递
        //  * apply 通过数组传递
        // */ 

        // function sum(a, b){
        //     console.log(this.total + a + b)
        // }

        // sum.call({total: 10}, 100,1000)
        // // => 1110

        // sum.apply({total: 20}, [200,2000])
        // // => 2220

        // let sum_v2 = sum.bind({total: 30}, 300, 3000)
        // sum_v2()
        // // => 3330
                
                
        // // bind 传递参数说明
        // // 第一个参数 === 函数内部的this指向
        // // 第二个参数 === 原函数的第一个参数
        // // 第三个参数 === 原函数的第二个参数 
        // // 依次类推
        // // 如果在bind的时候没有给函数传递参数or传递参数没有完全
        // // 可以在调用bind后返回的副本函数的时候再次传递
        // // 副本函数传递参数的时候 
        // // 第一个参数位置 === bind时已经传递的参数个数+1个
        // // 例如
        // // sum(a,b) 接受两个参数 
        // // sum_v3 = sum.bind({total: 50}, 形参a的实参) 已经传递了a参数
        // // 那么调用sum_v3的时候在再次传递的参数时从第二个位置开始
        // // sum_v3(形参b的实参)
        // // 参数 5000 会被忽略
        // let sum_v3 = sum.bind({total: 50}, 1)
        // sum_v3(500, 5000)
        // // => 551

 


        // // 一旦函数时bind返回的副本函数
        // // 即便这个函数作为某一个对象的方法调用
        // // 这个方法内部的this依然指向bind的对象
        // let tom = { 
        //     tom: 'tom',
        //     sayName: sayName_v2
        // }
        // // sayName 作为tom的方法调用原本内部的this应该时指向tom对象的
        // // 但是sayName是一个通过 【bind返回的函数】，
        // // 所以 sayName 方法一直指向 bind的对象
        // tom.sayName()



        // sayName_v2.call({name: "call-name"})
        // // call 无法修改 【bind返回的函数】 内部的this指向
        // // => bind-name

        // sayName_v2.apply({name: 'apply-name'})
        // // apply 无法修改 【bind返回的函数】 内部的this指向
        // // => bind-name

        // sayName_v2_bind_again = sayName_v2.bind({name: "bind-again-name"})
        // sayName_v2_bind_again()
        // // 一个bind返回的函数无法二次修改内部this指向
        // // => bind-name


        // // 偏函数
        // // 利用bind可以预先传递部分参数的功能实现偏函数
        // // 偏函数的概念： 固定一个函数的一个or多个实参，返回新函数用来接受剩余的参数
        // // bind 会固定函数内部的this所以最好不要用 bind 来实现偏函数 
        // function hello(pre, obj){
        //     console.log(`${pre}: ${obj.name}`)
        // }

        // const hello_cn = hello.bind(null, "你好：")
        // const hello_en = hello.bind(null, "hello")

        // hello_cn({name: '中文'})
        // hello_en({name: 'EN'})
 













        // 如果 bind 函数的参数列表为空，或者thisArg是null或undefined，执行作用域的 this 将被视为新函数的 thisArg。
        // 下面的理解有问题 始终指向了 window.name
        // 这个 执行作用域如何理解？？？？/
        // bind的实参第一个参数如果传递unll or undefined 
        // 【bind返回函数】 this 一定指向 bind()执行时候作用域的this
        // 这个执行作用域到底表示的是什么意思？？
       

        class Person {
            constructor(name){
                this.name = name
            }
            getThis(){
                function inside(){
                    console.log(this)
                }
                return inside.bind()
            }
        } 

        const bill = new Person('bill')

        const getThis = bill.getThis();

        getThis()
        // 如果 执行作用域的this 表示 bind()这个操作执行时所在的作用域
        // 预期输出 
        // => bill
        // 实际输出 
        // => undefined 
        // 表示 getThis 函数内部的this 指向的是 全局的this
        // 表示 执行作用域的this 并不是 bind()这个操作执行时所在的作用域

        let b = {
            name: 'b',
            getThis(){
                console.log(this)
                getThis()
            }
        }

        b.getThis()
        // 如果 执行作用域的this 表示 这个函数调用状态下所在作用域的this
        // 预期输出 
        // => { name: 'b', getThis: f}
        // => { name: 'b', getThis: f}
        // 实际输出
        // => { name: 'b', getThis: f}
        // => undefined
        // 表示 getThis() 执行时内部的this 并没有指向执行状态下作用域的this

                





        
 

       
    </script>
</body>
</html>