算法的本质需求
    - 实现对独立数据项的快速查找；
    - 一定要根据查找元素的条件设计算法，而不是 设计一个适用于所有条件的 查找算法

- 就是如何从逻辑层级 组合数据
    - 相同范围内的n个独立的数据体，我们可以采用 多个 整体引用对象 保存，
    - 引用对象只保存指针，所以不会而外增加太多的内存
    - 优秀的算法，能够实现在组合数据中的 快速 [增加 删除 修改 查找] 其中最核心的就是 查找
    - 能够快速的查找到我们的需要的独立数据，那么这个数据结构就是好的；
    - 如果不需要遍历，就不要遍历最好；
    - 独立的数据体， 可以根据不同的 查找条件 生成 完整数据体

    1：例如
        业务需求 
            - 我们需要知道 全国 考试成绩===90分同学数量
                - 算法思路
                    - 首先 在数据结构上, 我们要生成一个 已学生成绩位基础的 hash 表
                    - 直接从这个 hash 表上查询即可

        假设： 下面是全部学生的信息

        let bill = {id: "1", name: "bill", data: ""}

        let jack = {id: "2", name: "jack", data: ""}

        let tom = {id: '3', name: "tom", data: ""}

        let tom2 = {id: '4', name: 'tom', data: ""}



        // 数组的保存方式
        // 如果我们需要修改某一个学生的信息
        // 就需要查找到这个学生数据
        // 使用数组保存的，我们就需要遍历这个数组
        // 检查这个数组中的项，是否匹配我们查找的方式
        // 如果数组有 1000万条， 刚好查找的就是最后一条
        // 那么这个效率就非常的慢了;
        let student = [bill, jack, tom]

        // 用 hash 表来保存
        // hash 的生成标准 必须同我们之后查找的方式匹配起来
        // 例如
        // 如果我们查找是通过 name 属性，那么我们就可以
        // 根据 name 的属性值来生成 hash 值 
        // 

        例如： 如果我们需要用根据名称查找 可以设计成下的数据结构
        let arr = []
        let hashArray = [hash(bill.name), hash(jack.name), hash(tom.name),hash(tom2.name)]
        function hash(){} // 根据给地的字符串生成 hash 
        arr[hash(bill.name)] = [bill]
        arr[hash(jack.name)] = [jack]
        arr[hash(tom.name)] = [tom]
        arr[hash(tom2.name)] = [tom, tom2] // 采用数组处理hash冲突

        也可以采用
        let o = {}
        function hash(){}
        o[hash(bill.name)] = [bill]
        o[hash(jack.name)] = [jack]
        o[hash(tom.name)] = [tom]
        o[hash(tom2.name)] = [tom, tom2] // 采用数组处理hash冲突
        
        采用 arr 遍历较慢有许多的空位置[当然我们也可以配合另一个arr保存所有的hash值，直接这个保存hash值的数据也可以]
        采用 object 遍历较快

        业务需求2：
            - app 中有一个联系人列表页，里面保存的全部的联系人
            - 我们需要快速的 快速的找到名称 已 tom 开头 的人员
                - 算法思路
                    - 数据结构
                        - 根据 联系人的名称 生成 hash
                        - 而且必须把名称的字符串 拆开，一个字符一个字符的生成
                        - 例如 tom 可以把这个联系信息放到 has(t) hash(to) hash(tom) 的对应位置上
                        
                
