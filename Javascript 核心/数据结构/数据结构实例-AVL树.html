<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AVL</title>
</head>
<body>
    <ul>
        <li>AVL 树</li>
        <li>二叉搜索平衡树</li>
        <li>
            <ul>
                <li>1: 可能是一个空树</li>
                <li>2: 左右两个子树的高度差的绝对值不超过1, 且 左右两个子树页是平衡树</li>
            </ul>
        </li>
    </ul>
    <script>

        

        const _div_ = document.createElement('div')
        _div_.style.background = "red"
        _div_.style.color = "#fff"

        function appendSplit(message, background = null){
            const _div1_ = _div_.cloneNode(false)
            _div1_.innerText = message 
            _div1_.style.background = background ||  _div_.style.background;
            document.body.appendChild(_div1_)
        }

        

        // 教程位置
        // https://zhuanlan.zhihu.com/p/56066942  原理演示的非常清除
        // https://blog.csdn.net/rth362147773/article/details/78014586 js代码实现
        // AVL 树在每次插入的时候都需要检查 节点是否是平衡
        class AVLTreeNode{
            value;
            left;
            right

            constructor(value = null, left = null, right = null){
                this.value = value;
                this.left = left;
                this.right = right;
            }
        }

        class AVLTree{
            root 
            constructor(root = null){
                this.root = root;
            }

            LL_rotate(node){
                
                appendSplit('需要LL_roate 的节点： ', "#555")
                drawVALTree(node)
                
                const temp = node.left
                node.left = temp.right
                temp.right = node

                appendSplit(' LL_roate 之后的节点： ', "#555")
                drawVALTree(temp)
                return temp
            }

            RR_rotate(node){
                
                appendSplit('需要RR_roate 的节点： ', "#555")
                drawVALTree(node)

                const temp = node.right
                node.right = temp.left;
                temp.left = node;

                appendSplit(' RR_roate 之后的节点： ', "#555")
                drawVALTree(temp)
                return temp;
            }

            LR_rotate(node){
                appendSplit('需要LR_roate 的节点： ', "#555")
                drawVALTree(node)

                node.left = this.RR_rotate(node.left)
                node =  this.LL_rotate(node)

                appendSplit(' LR_roate 之后的节点： ', "#555")
                drawVALTree(node)

                return node
            }

            RL_rotate(node){
                
                appendSplit('需要RL_roate 的节点： ', "#555")
                drawVALTree(node)

                node.right = this.LL_rotate(node.right)
                node = this.RR_rotate(node)
                

                appendSplit(' RL_roate 之后的节点： ', "#555")
                drawVALTree(node)
                return node
            }

            insert(value){
                this.root = this.insertProcess(value, this.root)
                drawVALTree(this.root)
            }
            insertProcess(value, parentNode){
                if(!parentNode){
                    return new AVLTreeNode(value)
                }
                if(value < parentNode.value){ // 向左侧子节点插入
                    parentNode.left = this.insertProcess(value, parentNode.left)
                    // 插入完成后检查所有后代节点发生过修改的节点
                    // 也就是 所有经历过的节点都需要检查是否失去平衡
                    // 检查高度
                    // 超高子节点是 不平衡节点的左侧子节点 [L]
                    if(this.getHeight(parentNode.left ) - this.getHeight(parentNode.right) > 1){ // L
                        // value < left.value 表示插入的是 超高子节点的左侧 [L]
                        if(value < parentNode.left.value){ // L
                            // console.log('需要做平衡 --- LL', parentNode)
                            parentNode = this.LL_rotate(parentNode)
                            // console.log('平衡做完以后： ', parentNode)
                        }else{ // [R]
                            // console.log('需要做平衡 --- LR', parentNode)
                            parentNode = this.LR_rotate(parentNode)
                        }
                    }
                }else if(value > parentNode.value){ // 向右侧子节点插入
                    parentNode.right = this.insertProcess(value, parentNode.right)
                    if(this.getHeight(parentNode.right) - this.getHeight(parentNode.left) > 1){ // R
                        // console.log('需要做平衡 --- ')
                        if(value > parentNode.right.value){ // R
                            parentNode = this.RR_rotate(parentNode)
                        }else{ // L
                            parentNode = this.RL_rotate(parentNode);
                        }
                    } 
                }
                return parentNode
            }

            getHeight(node){
                if(!node){
                    return -1
                }else{
                    return Math.max(this.getHeight(node.left), this.getHeight(node.right)) + 1;
                }
            }

            /**
             * 删除指定的节点
             * 每次删除了这个节点 必须开始从这个节点向上检查 是否平衡
            */
            remove(v){
                appendSplit('开始删除： '+ v, "blue")
                this.root = this.removeProcess(v, this.root)
            
            }
            removeProcess(v, node){
                if(!node) return null;

                if(v < node.value){
                    node.left = this.removeProcess(v, node.left)
                }else if(v > node.value){
                    node.right = this.removeProcess(v, node.right)
                }else if(v === node.value){
                    if(!node.left && !node.right){
                        console.log('直接返回了 node = null')
                        node = null
                    }else if(!node.left && node.right){
                        node = node.right
                    }else if(node.left && !node.right){
                        node = node.left
                    }else{
                        // 查找到右边最小的值节点 作为临时节点
                        const temp = this.findMinNode(node.right)
                        node.value = temp.value;
                        // 删除 右边最小值的节点
                        node.right = this.removeProcess(temp.value, node.right)
                    }
                }

                // 删除的节点开始 从下到上 每一个节点都需要检查
                if(node){
                    const leftHeight = this.getHeight(node.left)
                    const rightHeight = this.getHeight(node.right)
                    if(leftHeight - rightHeight > 1){ // L
                        let ultrahighNode = node.left
                        if(this.getHeight(ultrahighNode.left) - this.getHeight(ultrahighNode.right) >= 0){ // L
                            node = this.LL_rotate(node)
                        }else{// R
                            node = this.LR_rotate(node)
                        }

                    }else if(rightHeight - leftHeight > 1){ // R
                        let ultrahighNode = node.right;
                        if(this.getHeight(ultrahighNode.left) - this.getHeight(ultrahighNode.right) > 0){ // L
                            node = this.RL_rotate(node)
                        }else{// R
                            node = this.RR_rotate(node)
                        }
                    }
                }

                return node
            }

            findMinNode(node){
                let minNode
                if(node.left){
                    minNode = this.findMinNode(node.left)
                }else{
                    minNode = node
                }

                return minNode
            }

            
            
        }

        function drawVALTree(node){
            // 遍历把 VALTree 转化成为
            const allNode = []
            function layoutTraverse(index, ...node){
                allNode[index] = [...node]
                let a = []
                node.forEach(item => {
                    a = [
                        ...a,
                        item ? item.left : null, 
                        item ? item.right : null,
                    ]
                })

                if(a.some(item => item)){
                    layoutTraverse(++index, ...a)
                }
            }
            layoutTraverse(0, node)
            
            const _canvas_ = document.createElement('canvas')
            _canvas_.width = 1000;
            _canvas_.height = 500
            _canvas_.style.width = "1000px";
            _canvas_.style.height= "500px";

            const ctx = _canvas_.getContext('2d');
            ctx.textAlign = 'center'
            ctx.font = "bold 22px serif"
            ctx.textBaseline  = "middle"
           

            const cellSize = 30
            const rowHeight = 100
           
            allNode.forEach((nodes, rowIndex, allNode) => {
                const len = nodes.length;
                const cellCount = 1000 / len;
                const positionY = rowIndex * rowHeight + rowHeight * 0.5
                
                nodes.forEach((node, colIndex, nodes) => {
                    // 当前元素的数量 == nodes.length
                    
                    if(!node)return 

                    const positionX = colIndex * cellCount + cellCount * 0.5
                
                    // 绘制指向左子元素的线条
                    const space = cellCount / 4
                    if(node.left){
                        const targetX = positionX - space;
                        const targetY = positionY + rowHeight;
                        ctx.beginPath();
                        ctx.moveTo(positionX, positionY);
                        ctx.lineTo(targetX, targetY);
                        ctx.stroke();
                    }

                    if(node.right){
                        const targetX = positionX + space;
                        const targetY = positionY + rowHeight;
                        ctx.beginPath()
                        ctx.moveTo(positionX, positionY)
                        ctx.lineTo(targetX, targetY)
                        ctx.stroke()
                    }
                     
                    ctx.beginPath()
                    ctx.ellipse(
                        positionX, 
                        positionY, 
                        30, 
                        30, 
                        0, 
                        0, 
                        2 * Math.PI, 
                        false
                    );
                    ctx.stroke()
                    ctx.fillStyle = "#fff"
                    ctx.fill()

                    ctx.fillStyle = "#333"
                    ctx.fillText(node ? node.value : null, positionX, positionY, cellCount)
                })
            })

            document.body.appendChild(_canvas_)
        }

        const avlTree = new AVLTree()

        Array.from([11,7,15,5,9,13,20,3,6,8,10,14,18,25]).forEach(v => {
            avlTree.insert(v)
        })
        appendSplit("完成了初始化树操作----")
        
        avlTree.remove(10)
        drawVALTree(avlTree.root)
        appendSplit("完成了 - 删除 10")
        
        
        avlTree.remove(8)
        drawVALTree(avlTree.root)
        appendSplit("完成了 - 删除 8")

        let delValue = 9
        avlTree.remove(delValue)
        drawVALTree(avlTree.root)
        appendSplit("完成了 - 删除 " + delValue )

        delValue = 3
        avlTree.remove(delValue)
        drawVALTree(avlTree.root)
        appendSplit("完成了 - 删除 " + delValue)

        delValue = 15
        avlTree.remove(delValue)
        drawVALTree(avlTree.root)
        appendSplit("完成了 - 删除 " + delValue)

        delValue = 20
        avlTree.remove(delValue)
        drawVALTree(avlTree.root)
        appendSplit("完成了 - 删除 " + delValue)

        delValue = 25
        avlTree.remove(delValue)
        drawVALTree(avlTree.root)
        appendSplit("完成了 - 删除 " + delValue)

        
         

       

        
        // 测试 数据
        // Array.from([5,3,6,4,2,1]).forEach(v => {
        //     avlTree.insert(v)
        // })

        // Array.from([2,1,5,4,6,7]).forEach(v => {
        //     avlTree.insert(v)
        // })

        // Array.from([5,2,6,1,4,3]).forEach(v => {
        //     avlTree.insert(v)
        // })

        // Array.from([5,1,8,6,9,7]).forEach(v => {
        //     avlTree.insert(v)
        // })


        // console.log(avlTree)
        // drawVALTree(avlTree.root)


    </script>
</body>
</html>